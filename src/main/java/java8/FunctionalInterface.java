package com.tarun;


import java.util.function.*;
import java.util.*;
import java.util.stream.*;


public class FunctionalInterface {
    public static void main(String args[]) {
        // Creating predicate
        Predicate<Integer> lesserthan = i -> (i < 18);

        // Calling Predicate method
        System.out.println(lesserthan.test(10));

        // predicate chaining

        Predicate<Integer> greaterThanTen = (i) -> i > 10;

        Predicate<Integer> lowerThanTwenty = (i) -> i < 20;

        // examples of and /  or 
        
        boolean result = greaterThanTen.and(lowerThanTwenty).test(21);
        System.out.println(result);
        result = greaterThanTen.or(lowerThanTwenty).test(18);

        System.out.println(result);

        // Consumer to display a number
        Consumer<Integer> display = a -> System.out.println(a);

        // Implement display using accept()
        display.accept(10);



        // Consumer to display a list of numbers
        Consumer<List<Integer> >
                dispList = list -> list.stream().forEach(a -> System.out.print(a + " "));

        //doesnt modify the list
        Consumer<List<Integer> >
                modify = list -> list.stream().map(a -> a*2).forEach(System.out::println);



        /* 

        info to see how modify would work, consumer should not modify
        
        Consumer to multiply 2 to every integer of a list - this will modify

        Consumer<List<Integer> > modify2 = list ->
        {
            for (int i = 0; i < list.size(); i++)
                list.set(i, 2 * list.get(i));
        };
        
          another way to do this: Multiply each element by 2 ->  list.replaceAll(n -> n * 2);
         
          numbers = numbers.stream().map(n -> n * 2).collect(Collectors.toList()); -> this creates a new list

        */


        modify.accept(list);
        dispList.accept(list);

        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        // Define a UnaryOperator to multiply by 2
        UnaryOperator<Integer> multiplyByTwo = n -> n * 2;

        // Modify list in-place
        numbers.replaceAll(multiplyByTwo);

        // Second function: Add 10
        Function<Integer, Integer> addTen = n -> n + 10;
        
        // The andThen() method is available in Function<T, R> and UnaryOperator<T> interfaces in Java 8. 
        //It is used to chain multiple functions together, where the output of the first function becomes the input of the second function.


        // Combine both functions using andThen()
        Function<Integer, Integer> combinedFunction = multiplyByTwo.andThen(addTen);

        // Apply the combined function
        int result = combinedFunction.apply(5);


        List<Integer> list = new ArrayList<Integer>();
        list.add(2);
        list.add(1);
        list.add(3);

    
        System.out.println("\n supplier interface \n");

        // This function returns a random value.
        Supplier<Double> randomValue = () -> Math.random();

        // Print the random value using get()
        System.out.println("random value  "  + randomValue.get() * 100000);

       

         // Define a Supplier for generating random integers
        Supplier<Integer> randomSupplier =  () -> new Random().nextInt();     //new Random()::nextInt;

        // Generate a stream of random integers using the Supplier
        Stream<Integer> randomStream = Stream.generate(randomSupplier);

        // Print first 5 random numbers
        randomStream.limit(5).forEach(System.out::println);

        /*

         Stream.generate(new Random()::nextInt)
                .limit(5).forEach(System.out::println);
        System.out.println("\n");
        
        */

        
        //Stream generate(Supplier<T> s) returns an infinite sequential unordered stream where each element is generated by the provided Supplier.

        int[] fibs = {0, 1};
        Stream<Integer> fibonacci = Stream.generate(() -> {
            int res = fibs[1];
            int fib3 = fibs[0] + fibs[1];
            fibs[0] = fibs[1];
            fibs[1] = fib3;
            return res;
        });
        System.out.println("\n");

        fibonacci.limit(10).forEach(i->System.out.print(i+"  "));

        // Array fibs is shared across multiple stream operations. In single-threaded scenarios, this will work fine.
    
         // Generate Fibonacci sequence using Stream.iterate
        Stream<Integer> fibonacci2 = Stream.iterate(new int[]{0, 1}, f -> new int[]{f[1], f[0] + f[1]})
                                          .map(f -> f[0]);

        // Print first 10 Fibonacci numbers
        fibonacci2.limit(10).forEach(System.out::println);

        /*
        
        Stream<T> iterate(T seed, UnaryOperator<T> f)
                 seed: The initial value (the first element in the sequence).
                    f: A function that takes the previous element and returns the next element.
        
        */
     

    }
}
